# -*- coding: utf-8 -*-
"""Python Data basics

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A6c5IVU-hl4iU8Sx5llxNghXflKWbhcA
"""

#Basic operations
savingsAccount = 1000
checkingAccount = 500

# add 100 to our savings
savingsAccount = savingsAccount + 100

# remove 50 from our checkingaccount
checkingAccount = checkingAccount - 50

# calculate the number of days to save to reach 5000
numberDaysSave = (5000 - checkingAccount) / 500

# update our checkingaccount (again) after the daily gains/losses
checkingAccount = checkingAccount + (30 - 10) * 7

print(SavingsAccount % 500) # -> 100
# 1100 = 500 * 2 + 100, so 1100 % 500 = remainder = 100

print(9 ** 3) # -> 729, 9*9*9 = 729

print(SavingsAccount // 500) # -> 2
# 1100 = 500 * 2 + 100, so 1100 // 500 = integer division result = 2*

"""# Operators
    + : addition

    - : subtraction

    * : multiplication

    / : division

    % modulo : returns the remainder of the euclidean division

    ** power : raises a number to a certain power

    // integer division: calculates the integer division (rounded down)

  # Simplified operators
    -=  for subtraction

    *=  for multiplication

    /=  for division

    %=  for the remainder of the integer division

    etc.

#Variables types
    Integer variables (int)

    Decimal variables (float), int can be stored as floats

    Character strings (string), defined with " or '

#Casting
Forces a conversion

    int() : for integers

    float() : for decimals

    str() : for strings

# Functions
Many functions are presnt in python
You can use `help(functionName)` to print doc
    len() :  returns the length of an item

    type() : lets you print the type of a variable.

    pow(a, b) : lets you calculate a to the power of b. equivalent to a**b.

    abs() :  returns the absolute value of a number.

    round() : Rounds the number, you can precise round(nb, digits) to precise how many digits you want

# Writing your own functions

    def functionName(param1, param2):
        total = param1 + param2
        print(total)

# Return values
    def functionName(param1, param2):
        total = param1 + param2
        return total

Python is **object-oriented**, meaning that every variable is an instance of an object, with its own **methods**

## Strings
    upper() : returns whole text in upper case
    capitalize() : returns whole text in lower case except first letter capitalized
    replace(old, new)
    find(string) : returns index of first occurence of string or -1
    startswith(value) : returns True if string begins exactly with the value

# Lists
Ordered objects, with an index for each element starting with 0.
You can store several different objects in the same list.

    customerName = ['Marion Weaver', 'Alberto Mendoza', 'Katharine Tyler', 'IsaacÂ·Steele']

    customerName[0] = 'Marianne Weaver'

Access last item

    print(customerName[-1])

And the one before

    print(customerName[-2])

Access to several items
    # access the second item to the 3rd
    print(customerName[1:3])

    # access all items from the beginning to the second
    print(customerName[:2])

# Methods

    list.append(value) => Adds value to the end
    list.insert(position, element) => Adds to a specific spot
    list.extend(list) => append but with another list, to concatenate
    list.remove(value) => Removes the 1st occurence of the parameter
    list.index(value) => Gives the index of 1st occurence of the parameter
    del list[index] => Deletes an item with its index
    len(list)

#Dictionaries
List of items organized via a system of keys, key-value pairs.
Key must be unique.
They use curly brackets {} and : for key/value declaration

    accounts = {'Marion Weaver': 10000, 'Alberto Mendoza': 150, 'Katharine Tyler': 300, 'Isaac Steele': 1800.74}
    print(accounts['Alberto Mendoza']) # -> 150

To add a new element simply access it to the corresponding key

    accounts['Kristian Roach'] = 1000 # I add a new individual in my dictionary

## Methods

    dict.pop('key') => Removes a pair
    len(dict)

# Immutable tuples
Similar to lists, ordered objects, but they can not be modified (immutable)
They use parentheses () instead of square brackets []

    my_tuple = (1, 2, 3, 'a', 'b')
    print(my_tuple[1]) # -> 2
    print(my_tuple[4]) # -> 'b'

We can declare several variables at the same time

    a, b = (1, 'apple')
    print(a) # -> 1
    print(b) # -> 'apple'

### **They are immutable !**

# Conditionnal structures
    if:
    elif: #several elif possible
    else:

## Booleans
Variable that can only be True or False
The result of a comparison can be evaluated to a boolean

## Comparison operators
    ==  equal to (two values are exactly the same)
    !=  different from
    <  less than
    <=  less than or equal to
    >  greater than
    >=  greater than or equal to

## Logical operators
To be able to mix several boolean values

    and : true only when all expressions/values are true.
    or : true when at least one of the expressions/values is true.
    not() : reverses the result of the given expression.
    in : returns true when a value is found in a sequence

Parenthesis can be used, and not() is executed first

#Loops
## For loop
Used to iterate a set number of tmes, only through a collection (unlike other languages)

    myString = "Items"

    for elt in myString:
        print(elt)

We can simulate a collection if we want to iterate a certain number of times

    range(start, stop, step) created a collection from start to stop (not included, until stop -1), with step in between
    range(start, stop) works
    range(stop) begins with 0

## While loop

Runs as long as the condition is met

    numberTrees = 0

    while numberTrees < 10:
        numberTrees += 1
        print("I planted", numberTrees, "trees")

    print("I have a nice forest!")

## Skip statements
`continue` allows to go to the next iteration without executing the rest of the loop this time

`break` exits loop

# Modules
Modules are a piece of code that you may want to use to simplify your task, included in 1 file
To use them

    import geometry
  
then we use methods from this module

    squa = geometry.square(4)
    print(geometry.pi)

We can give alias

    import geometry as geo

And do selective import

    from geometry import pi
    print(pi) # -> 3.14159265359

Using * is possible but bit recinnabded because of conflicts

    from geometry import *

# Packages
A collection of modules, each in a different file

    import geometry.variables as var # import only what is defined in variables.py
    print(var.pi) # -> 3.1415...

## Data analysis
Used to manipulate data, make graphs, use statistical methods, run machine learning algo ...
ex: numpy

## Ex : Random package

    import random
    random.random() generates random between 0 and 1
    random.uniform(a, b) generates random float btween a and b
    random.randint(a, b) generates random int between a and b
    random.gauss(mean, standardDeviation) generates a gaussian random around mean
    random.choice(list) random from a list
    random.choices(list, k=size) random from a list, but gives a list of size elements
    random.sample(list, size) guarantees that each sample is unique

# Numpy

Numerical Python providing a new object : the NumPy array, with must faster functions. It can only contain a single data-type.

## Creating arrays

    import numpy as np
    np_array = np.array(array)
    np_array.dtype => Gives the data type of elements in the array. Composed of data type (int) and precision (32 for example, nb of bits used to code it)

    np_array = np.zeros(n) => Create array of 0 with n elements
    np_array = np.zeros(x, y) => Create a table of 0 with x width, y length

    np_array = np.ones(n) => Create array of 1 with n elemnts
    np_array = np.ones(x, y) => Create a table of 1 with x width, y length
   
    np_array = np.arrange(i, j, p) => Create array of linear sequence from i to j in steps of p

    np_array = np.linspace(i, j, n) => Create array of n evenly spaced values between i and j

    np_array = np.random.random((x, y)) => Creates a x*y table containing random values between 0 and 1

    np_array = np.random.randint(i, j, size=(x, y)) => Creates a x*y table filled with random integers from i to j

## Accessing elements

    array_name[i:j:p] => i start element index, j final element index (excluded), p step
    array_name[i:j] => i start element index, j final element index (excluded), step of 1
    array_name[:j] => from 0 index, to j final element index (excluded), step of 1
    array_name[i:] => from i index, to the end, step of 1
    array_name[::2] => from 0 index, every other element
    array_name[::-1] => from the end to the 0 index reversed
    
    array_name[array_name condition] => Writing a condition creates an array of boolean values, ex : income_array[income_array > 2000]
    array_name[(array_name condition) & (array_name condition)] => Multiple conditions, ex : income_array[(income_array > 2000) & (income_array < 3000)]

    table[x,y] => Accesses with index a value in a table (x = line, y column)
    table[x, :] => Access the entire column at x index
    table[:, y] => Access the entire row at y index
    
    Mixable with conditions !
    table[table[:, 2] <= 25] => Creates an array with every line respecting a value <= 25 in the 3rd column

## Modifying elements

    income_array[3] = 1790 modifies value of the 4th element
    income_array[income_array > 2000] = 0 modifies value of every element corresponding to the condition
    np.vstack((array, new_data)) => adds informations to the end, must be a table with the right number of columns

## Methods

    display(np_array)
    np.mean(np_array) => Mean
    np_array.shape => Number of elements
    np_array.max()
    np_array.min()
    np_array.argmin() => Index of min
    np_array.argmax() => Index of max
    np_array.sort() => Sorting
    np_array.sum() => Calculates the sum

## Matrix

When matrix have the same dimension, we can add them simply with + and multiply them with *


    A = np.array([[1, 2], [3, 4]])
    B = np.array([[5, 10], [15, 20]])
    A+B
    A*B

When the dimensions are different, we use @ operator (Py 3.5 and above) or the dot function (before Py 3.5)

    A = np.array([[1, 2], [3, 4]])
    C = np.array([[2, 4, 6], [8, 10, 12]])
    A@C or AC = np.dot(A,C)

# Dataframes

Library panda offers dataframes, a way to store data in tables where columns are named. A single column can contain only one data type.
Generated from excel, csv, json ...

    import pandas as pd
    customers = pd.read_csv("customers.csv")
    display(customers) -> Renders (watch out, max 60 rows)
    array = dataframe.values -> Transform DataFrame to array

## Identify attributes

    .head() -> Select 5 first row, nb of rows can be specified as a parameter
    .tail() -> Select 5 last row, nb of rows can be specified as a parameter
    .shape -> Gives an array with number of rows, number of columns
    .dtypes -> Gives the list of types, objects = string data

## Navigate

    df[column] -> Access to the column
    df[[column1, column2]] -> Access to 2 columns, possible from an array of column names

When accessing a column, we get a Series. They can contain only 1 type of data.

## Modify values

    df[column] = 1 -> Changes the value of each row in the column to 1
    df[column] = df[column] * 10 -> Multiplies the value of each row in the column by 10
    df[column] = np.random.randint(1, 1000, df.shape[0]) -> Changes values with random from 1 to 1000
  
    df[new_column] = ... -> Created a new column
  
    df.drop(columns='id') -> Deletes the column 'id', returns a COPY of the dataframe so use df = df.drop(columns='id')
    del df['id'] -> Deletes the column 'id'
    df.pop('id') -> Deletes the column 'id'

    df.rename(columns={'old name': 'new name'}) -> Renames a column, returns a COPY of the dataframe if inplace=True is not set
    df.rename(columns={'old name': 'new name'}, inplace=True) -> Renames a column

    df['identifier'].astype(float) -> Changes the type of a column, returns a COPY of the dataframe

    df.sort_values('column') -> Sorts in ascending order a column
    df.sort_values('identifier', ascending = False) -> Sorts in descending order a column
    When you put several columns you can put several flags to ascending

    df.reset_index() -> Resets index
    df(df.reset_index(drop=True)) -> reset_index without retaining the old indices, otherwise it creates an index column with old values. Option inplace=True possible, otherwise gives another instance of df

## Select values

### Based on integer positions

    my_dataframe.iloc[index_row, index_column]
    customers.iloc[:10, 2] -> select the 3rd column of the first 10 customers
    customers.iloc[:10, :] -> select all the columns of the first 10 customers
    customers.iloc[10:20, 1:3] -> select column 2 to 4 for the next 10 customers (so the loc before : is exclusive)
    customers.iloc[-10:, [1, 3]] ->  elect column 2 and 4 for the final 10 customers

## Based on conditions

    my_dataframe.loc[condition on rows, column(s)]
    df[df['column'] == 'condition', :] -> selects all columns for rows respecting the condition on the column
    df[df['column'] == 'condition', :].shape[0] -> counts the values
    df[(df['column1'] == 'condition1') & (df['column2'] == 'condition 2'), :] -> selects all columns for rows respecting the condition 1 on the column1 and the condition 2 in column 2, also possible with | (or)

& and | are possible to use between conditions
When manipulating with a condition and wanting to change the value, we need to write again the condition after the =
The good practice is to use a mask

    mask = condition, ex : mask = df['column'] == 'value'
    df[mask, :] = df[mask, :] + 5

# Calc functions on columns

    df['column'].sum()
    df['column'].mean()

# Aggregate rows

Allows for instance to calc statistics on a specific option.
The label becomes the column !
Similar to GROUP BY in SQL

    loans.groupby('city') -> We get 1 line for each different city available
    Then we can use .sum() or .mean()

If we want to divide by 2 parameters (ex : each city and each type for each city) we can do :

    loans.groupby(['city', 'type'])

Then we can access 1 variable only from 'type'

    loans.groupby(['city', 'type'])['repayment'].sum() -> Will show the sum of repayment for each type in each city

To restore columns we can use

    reset_index

If we want to have a column for each 'type' we can use pivot table

    .pivot_table(index='city', columns='type', values='repayment', aggfunc='sum')
    It will have each city as ROWS, 1 column for each type, showing the SUM of REPAYMENT values

Application : We want for each identifier (client) a table wit the sum of each element, we use

    customer_profile = loans.groupby('identifier')[['repayment','debt_to_income','total_cost','profit']].sum()

# Joining data

We can join data from different datasets. They need to have a common data item, called a "Key", this is "horizontal concatenation"

2 ways

    pd.merge(A,B) -> Pandas function
    A.merge(B) -> DataFrame method

By default, pandas tries to find common columns, this is a **natural joint**.
We can also specify it. When the key has the same name in each DF, we can use **on** argument. Otherwise, we use **right_on** and **left_on** arguments.

    pd.merge(A, B, on='id')
    B.merge(A, left_on='identifier', right_on='id') -> Left = B, right = A
    pd.merge(A, B, left_on='id', right_on='identifier')

Different types of join exist :    
 - Inner : by default, contains only rows from 1st DF also present in 2nd DF
 - Left : focuses on identifiers found in left table, fills blanks with missing values (NaN)
 - Right : focuses on identifiers found in right table, fills blanks with missing values (NaN)
 - Outer : keeps all ID, fills missing values with NaN

     pd.merge(heights, weights, on='id', how='inner') -> Gives only data present for id in each table
     pd.merge(height, weights, on='id', how='left') -> Gives only data with id present in left table
     pd.merge(height, weights, on='id', how='outer') -> Takes every id from each table

# Concatenating data

When new data is available that we want to append to the table, we use concatenation. The 2 df need to have the same structure.

    pd.concat([df1, df2], ignore_index=True) -> ignore_index allows index to be reset, to avoid duplicate index problems

# Visualization / Dataviz

Essential to analyze data.

*   Data changing over time -> Line, curve graph, bar chart
*   Compare 2 groups -> Circle graph
*   Compare more groups -> Bar chart
*   Display distribution -> Histogram, density chart
*   Relqtion between 2 numeric variables -> Scatter plot

Key principles :
*   Simplicity
*   Clarity : with titles, legend, values above bars for precision

# Matplotlib

```
import matplotlib.pyplot as plt
```
Modeled on MATLAB language.



*   Scatter plots:  scatter()
*   Line or curve diagrams:  plot()
*   Bar charts:  bar()
*   Histograms:  hist()
*   Pie charts:  pie()
"""
